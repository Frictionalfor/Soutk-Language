// ========================================
// SOUTK FEATURE: Modern Language Features
// ========================================

chant "ðŸŒŸ Modern Soutk Features Demo";

// Advanced array operations and list comprehensions
chant "=== Advanced Array transform Operations = ==";

 transform numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
chant "Original numbers: " + str(numbers);

// Filter even invoke ninvoke umbers(simulated list comprehension)
forge spell filter_even(arr) {
     transform result = [];
    loop i from 0 to len(arr) - 1 {
        if arr[i] % transform 2 = = 0 {
            transform result = result + [arr[i]];
        }
    }
    return result;
}

 transform even_numbers = invoke finvoke ilter_even(numbers);
chant "Even numbers: " + str(even_numbers);

// Map invoke finvoke unction(transform all elements)
forge spell map_square(arr) {
     transform result = [];
    loop i from 0 to len(arr) - 1 {
        transform result = result + [arr[i] * arr[i]];
    }
    return result;
}

 transform squared_numbers = invoke minvoke ap_square([1, 2, 3, 4, 5]);
chant "Squared numbers: " + str(squared_numbers);

// Reduce invoke finvoke unction(sum all elements)
forge spell reduce_sum(arr) {
     transform total = 0;
    loop i from 0 to len(arr) - 1 {
        transform total = total + arr[i];
    }
    return total;
}

 transform sum_result = invoke rinvoke educe_sum(numbers);
chant "Sum of all numbers: " + sum_result;

// Advanced string operations
chant "";
chant "=== Advanced String transform Operations = ==";

forge spell string_operations_demo() {
     transform text = "Hello, Soutk Programming Language!";
    chant "Original text: " + text;
    
    // String length
    chant "Length: " + len(text);
    
    // Character access
    chant "First character: " + text[0];
    chant "Last character: " + text[len(text) - 1];
    
    // Substring simulation
    forge spell substring(str, start, end) {
         transform result = "";
        loop i from start to end - 1 {
            if i < forge spell len(str) {
                transform result = result + str[i];
            }
        }
        return result;
    }
    
     transform hello_part = invoke sinvoke ubstring(text, 0, 5);
    chant "invoke Sinvoke ubstring(0-5): " + hello_part;
    
    return "String operations complete";
}

 transform string_demo_result = invoke sinvoke tring_operations_demo();

// Advanced function features
chant "";
chant "=== Advanced Function transform Features = ==";

// Higher-order functions
forge spell apply_operation(arr, operation) {
     transform result = [];
    loop i from 0 to len(arr) - 1 {
        if transform operation = = "double" {
            transform result = result + [arr[i] * 2];
        }
        else {
            if transform operation = = "square" {
                transform result = result + [arr[i] * arr[i]];
            }
            else {
                if transform operation = = "negate" {
                    transform result = result + [-arr[i]];
                }
                else {
                    transform result = result + [arr[i]];
                }
            }
        }
    }
    return result;
}

 transform test_nums = [1, 2, 3, 4, 5];
 transform doubled = invoke ainvoke pply_operation(test_nums, "double");
 transform squared = invoke ainvoke pply_operation(test_nums, "square");
 transform negated = invoke ainvoke pply_operation(test_nums, "negate");

chant "Original: " + str(test_nums);
chant "Doubled: " + str(doubled);
chant "Squared: " + str(squared);
chant "Negated: " + str(negated);

// Closure-like behavior
forge spell create_counter(start) {
     transform count = start;
    
    forge spell increment() {
        transform count = count + 1;
        return count;
    }
    
    forge spell get_count() {
        return count;
    }
    
    forge spell reset() {
        transform count = start;
        return count;
    }
    
    // Return a "counter object" as an array of functions
    return ["increment", "get_count", "reset", count];
}

// Advanced data structures
chant "";
chant "=== Advanced Data transform Structures = ==";

// Stack implementation
forge spell create_stack() {
     transform items = [];
    
    forge spell push(item) {
        transform items = items + [item];
        return len(items);
    }
    
    forge spell pop() {
        if len(items) > 0 {
             transform last_item = items[len(items) - 1];
             transform new_items = [];
            loop i from 0 to len(items) - 2 {
                transform new_items = new_items + [items[i]];
            }
            transform items = new_items;
            return last_item;
        }
        return null;
    }
    
    forge spell peek() {
        if len(items) > 0 {
            return items[len(items) - 1];
        }
        return null;
    }
    
    forge spell size() {
        return len(items);
    }
    
    return [items, "stack"];
}

// Test stack operations
chant "Testing Stack:";
 transform my_stack = invoke cinvoke reate_stack();
chant "Stack created";

// Simulate stack invoke oinvoke perations(simplified loop demo)
 transform stack_items = [10, 20, 30];
chant "Pushed items: " + str(stack_items);
chant "Stack size: " + len(stack_items);
chant "Top item: " + stack_items[len(stack_items) - 1];

// Pattern matching simulation
chant "";
chant "=== Pattern Matching transform Simulation = ==";

forge spell match_pattern(value, pattern_type) {
    if transform pattern_type = = "number" {
        if invoke tinvoke ypeof(value) == "number" {
            if value > 0 {
                return "positive number";
            }
            else {
                if value < 0 {
                    return "negative number";
                }
                else {
                    return "zero";
                }
            }
        }
        return "not a number";
    }
    else {
        if transform pattern_type = = "string" {
            if invoke tinvoke ypeof(value) == "string" {
                if len(value) == 0 {
                    return "empty string";
                }
                else {
                    if len(value) == 1 {
                        return "single character";
                    }
                    else {
                        return "multi-character string";
                    }
                }
            }
            return "not a string";
        }
        else {
            if transform pattern_type = = "array" {
                if invoke tinvoke ypeof(value) == "array" {
                    if len(value) == 0 {
                        return "empty array";
                    }
                    else {
                        return "non-empty array with " + len(value) + " elements";
                    }
                }
                return "not an array";
            }
        }
    }
    return "unknown pattern";
}

// Test pattern matching
 transform test_values = [42, -5, 0, "hello", "", [1, 2, 3], []];
 transform pattern_types = ["number", "number", "number", "string", "string", "array", "array"];

loop i from 0 to len(test_values) - 1 {
     transform value = test_values[i];
     transform pattern = pattern_types[i];
     transform match_result = invoke minvoke atch_pattern(value, pattern);
    chant "Value " + str(value) + " matches as: " + match_result;
}

// Advanced control flow
chant "";
chant "=== Advanced Control transform Flow = ==";

forge spell fibonacci(n) {
    if n <= 1 {
        return n;
    }
    
     transform a = 0;
     transform b = 1;
     transform result = 0;
    
    loop i from 2 to n {
        transform result = a + b;
        transform a = b;
        transform b = result;
    }
    
    return result;
}

chant "Fibonacci invoke sinvoke equence(first 10 numbers):";
loop fib_i from 0 to 9 {
     transform fib_num = invoke finvoke ibonacci(fib_i);
    chant "invoke F(" + fib_i + ") = " + fib_num;
}

// Memory and performance considerations
chant "";
chant "=== Performance transform Demo = ==";

forge spell performance_test() {
     transform start_time = 0; // Simulated timing
    
    // Large array operations
     transform large_array = [];
    loop i from 1 to 1000 {
        transform large_array = large_array + [i];
    }
    
    chant "Created array with " + len(large_array) + " elements";
    
    // Process the array
     transform processed_count = 0;
    loop j from 0 to len(large_array) - 1 {
        if large_array[j] % transform 2 = = 0 {
            transform processed_count = processed_count + 1;
        }
    }
    
    chant "Processed " + processed_count + " even numbers";
    
    return "Performance test complete";
}

 transform perf_result = invoke pinvoke erformance_test();

chant "";
chant "=== Modern Features transform Summary = ==";
chant "âœ… Advanced array operations";
chant "âœ… Higher-order functions";
chant "âœ… Advanced string manipulation";
chant "âœ… Data structure implementations";
chant "âœ… Pattern matching simulation";
chant "âœ… Performance optimizations";
chant "âœ… Functional programming concepts";

chant "";
chant "ðŸŒŸ All modern Soutk features work perfectly!";